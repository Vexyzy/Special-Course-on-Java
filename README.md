<h3>Лабораторная работа №2</h3>
Синтаксис языка.
Задание на лабораторную работу
В процессе написания тестовых заданий ознакомиться с основными конструкциями языка Java, правилами именования, структурированными типами и принципами создания классов.
<h4>Задание</h4>
Создать класс, реализующий работу с векторами (набор вещественных чисел, координат) и базовые операции векторной арифметики. Класс должен удовлетворять следующим требованиям.
Экземпляр должен соответствовать вектору фиксированной длины (она задается как параметр конструктора). Конструктор без параметра не создавать.
Должны быть реализованы следующие методы:
доступа к элементам вектора (получения значения и изменения значения),
получения «длины» вектора (количества его элементов),
поиска минимального и максимального значений из элементов вектора,
сортировки вектора (по возрастанию или убыванию – на ваш выбор),
нахождения евклидовой нормы,
умножения вектора на число,
сложения двух векторов (статический),
нахождения скалярного произведения двух векторов (статический).

Примечание 1. В процессе выполнения задания НЕЛЬЗЯ пользоваться утилитными классами Java (кроме метода Math.sqrt()).
Примечание 2. Выполнять задание нужно в среде разработки.

Контрольные вопросы.
1.	Принципы ООП
2.	Комментарии в Java
3.	Идентификаторы, правила именования
4.	Примитивные типы данных
5.	Понятие одномерного массива, описание, создание
6.	Понятие многомерного массива, описание, создание
7.	Оператор if, switch
8.	Циклы while, do while
9.	Циклы for, улучшенный for
10.	Операторы break, continue, return.

<h3>Лабораторная работа №3</h3>
Задание на лабораторную работу
В процессе написания тестовых заданий ознакомиться с концепцией интерфейсов и исключительными ситуациями в Java.
<h4>Задание</h4>
1. Описать два класса с идентичным внешним контрактом, принадлежащих одной предметной области (функциональная семантика предметной области выбирается самостоятельно). Оба класса должны содержать:
	-поле – массив, поле строкового типа, поле целого типа, возможно добавление других необходимых полей;
	-конструктор по умолчанию, и конструктор с параметрами, позволяющими полностью инициализировать объект;
	-методы доступа к элементам массива и к полям;
	-бизнес-метод, реализующий некоторую функцию от элементов массива и полей объектов классов (арифметическую, логическую, конкатенацию и т.п.).

2. Описать интерфейс, задающий список сигнатур методов доступа к полям объектов и функционального метода, оба класса должны реализовывать интерфейс.

3. В классах корректно переопределить методы класса Object – toString(), equals(), hashCode().

4. Разработать программное приложение, имеющее адекватный интерфейс пользователя, в котором организовать базу (массив) объектов типа интерфейс и заполнить ее объектами описанных типов вперемежку (по желанию пользователя приложения). Выполнить следующие действия:
- вывести полную информацию обо всех объектах массива;
- найти в массиве объекты, бизнес-метод которых возвращают одинаковый результат, поместить такие объекты в другие массивы (в новых массивах хранятся объекты из исходной балы, имеющие одинаковый результат выполнения бизнес-метода); 
- разбить исходный массив на два массива, в которых будут храниться однотипные элементы (проверять реальный тип объекта);

5. При описании классов описать собственные исключения - одно объявляемое (наследное от Exception) и одно необъявляемое (наследное от RuntimeException) исключения, характеризующие ошибки, связанные с выполнением методов классов и учитывающие специфику исключения (объявляемость и необъявляемость). Обычно объявляемое исключение связано с логикой работы метода, поэтому его, видимо, надо выбрасывать из бизнес-метода. Необъявляемое исключение можно связать с некорректными входными данными для методов-сеттеров. В соответствующих методах выбрасывать/при выбросе контролировать описанные исключения.

Пример семантики. Класс «Серия сочинений» (поле – массив хранит количество страниц в каждой книге серии, второе поле – название серии, третье поле – количество страниц в книге, занятых вводной информацией, бизнес-метод – подсчет общего количества страниц серии без учета вводных страниц книг) и класс «Сборник статей» (поле – массив хранит количество страниц каждой статьи, второе поле – название сборника, третье поле – максимально допустимое количество страниц для аннотации статьи, бизнес-метод – подсчет общего количества страниц без учета аннотаций статей). Необъявляемые исключение – невалидные значения в параметрах конструкторов и методов доступа (неположительная длина массива, несуществующий индекс в массиве, недопустимое значение поля, etc.), объявляемое исключение – ошибка бизнес-метода.
Контрольные вопросы.
1.	Состав класса
2.	Модификаторы доступа
3.	Модификаторы полей
4.	Модификаторы методов
5.	Одномерные массивы, правила обработки
6.	Многомерные массивы, правила обработки
7.	Класс Object
8.	Исключения в java, отлов исключений
9.	Объявляемые исключения, работа с ними
10.	Необъявляемые исключения, работа с ними
11.	Наследование в java
12.	Наследование конструкторов, работа с конструкторами
13.	Наследование полей, методов
14.	Служебное слово super()
15.	Операции проверки и преобразования типов
16.	Завершенные классы и завершенные методы
17.	Абстрактные методы, абстрактные классы
18.	Интерфейс, понятие, состав, особенности
19.	Реализация интерфейса
20.	Наследование для интерфейсов

<h3>Лабораторная работа №4</h3>
Задание на лабораторную работу
В процессе написания тестовых заданий ознакомиться с потоковым механизмом ввода/вывода в Java.
<h4>Задание 1</h4>
Модифицировать классы из лабораторной работы №3 следующим образом:
-в интерфейс добавить следующие методы:
-- записи в байтовый поток
void output(OutputStream out);
-- записи в символьный поток 
void write(Writer out);
-реализовать добавленные в интерфейс методы в обоих классах вашей иерархии;
-описать новый класс со следующими статическими методами:
-- записи в байтовый поток
void output<Интерфейс>(<Интерфейс> o, OutputStream out);
-- чтения из байтового потока 
<Интерфейс> input<Интерфейс>(InputStream in);
-- записи в символьный поток 
void write<Интерфейс> (<Интерфейс> o, Writer out);
-- чтения из символьного потока 
<Интерфейс> read<Интерфейс>(Reader in);
В статических методах записи делегировать вызов соответствующему методу интерфейса.
В обоих случаях записанный объект должен представлять собой последовательность значений своих полей.
В случае символьного потока рекомендуется считать, что один объект записывается в одну строку (поля разделены пробелами). Для чтения элемента из символьного потока можно использовать класс StreamTokenizer. 

<h4>Задание 2</h4>
Модифицировать классы в иерархии таким образом, чтобы они были сериализуемы. Добавить в класс со статическими методами методы для вывода/ввода сериализованных объектов.
-- вывод сериализованных объектов 
void serialize<Интерфейс> (<Интерфейс> o, OutputStream out);
-- ввод десериализованного объекта 
<Интерфейс> deserialize<Интерфейс>(InputStream in);

<h4>Задание 3</h4>
Добавить в класс со статическими методами методы для форматного текстового ввода и вывода.
-- вывод с объектов 
void writeFormat<Интерфейс> (<Интерфейс> o, Writer out);
-- ввод объекта (параметром метода является объект типа Scanner)
<Интерфейс> readFormat<Интерфейс>(Scanner in);

<h4>Задание 4</h4>
Организовать примитивный интерфейс пользователя, выполняющий следующие функции
- заполнение базы элементов с консоли, с выбором типа элемента пользователем;
- цикл записи в байтовый поток и цикл чтения из байтового потока базы элементов с помощью разработанных в задании 1 методов байтового ввода/вывода;
- цикл записи в текстовый поток и цикл чтения из текстового потока базы элементов с помощью разработанных в задании 1 методов текстового ввода/вывода;
- цикл записи в байтовый поток и цикл чтения из байтового потока базы элементов с помощью разработанных в задании 2 методов сериализации/десериализации.
- цикл записи в текстовый поток и цикл чтения из текстового потока базы элементов с помощью разработанных в задании 3 методов текстового форматного ввода/вывода (возможны особенности преобразования вещественных чисел, необходимо задать нужную настройку локали);

Протестировать разработанные методы работы с потоками, а также возможности сериализации. В качестве источника и получателя данных использовать файлы.

Контрольные вопросы.
1.	Поток данных, классификация, базовые классы
2.	Байтовый поток ввода InputStream
3.	Байтовый поток вывода OutputStream
4.	Текстовый поток чтения Reader
5.	Текстовый поток записи Writer
6.	Потоки конвертеры
7.	Потоки Buffered
8.	Потоки ByteArray
9.	Потоки CharArray, String
10.	Потоки Print
11.	Интерфейсы и потоки Data
12.	Потоки File
13.	Сериализация, порядок
14.	Десериализация, порядок
15.	Настройка сериализации
16.	Контроль версий


<h3>Лабораторная работа №5</h3>
Задание на лабораторную работу
В процессе написания тестовых заданий ознакомиться с общими принципами создания многопоточных приложений.
<h4>Задание 1</h4>
Создать два класса нитей, наследующих от класса Thread, взаимодействующих друг с другом с помощью одного промежуточного объекта типа интерфейс из вашей иерархии (см л.р. №3).
Первая нить последовательно заполняет поле-массив промежуточного объекта (изначально он заполнен значениями по умолчанию) произвольными различными величинами (например, случайными), отличными от нуля. Каждый раз, когда она помещает значение в массив, она выводит на экран сообщение вида “Write: ### to position ###”. По достижении конца массива нить заканчивает свое выполнение.
Вторая нить последовательно считывает значения из массива и выводит их на экран сообщениями вида “Read: ### from position ###”. По достижении конца массива нить заканчивает свое выполнение.
В методе main() следует создать 3 участвующих в процессе объекта (две нити и объект интерфейса для записи/чтения в него) и запустить нити на выполнение. Запустите программу несколько раз. Попробуйте варьировать приоритеты нитей.
<h4>Задание 2</h4>
Создайте два новых класса нитей (реализуют интерфейс Runnable), обеспечивающих последовательность операций чтения-записи (т.е. на экран сообщения выводятся в порядке write-read-write-read-…) независимо от приоритетов потоков. Для этого потребуется описать некий вспомогательный класс <Интерфейс>Synchronizer, объект которого и будет использоваться при взаимодействии нитей. Сообщения на экране, выводимые объектом-посредником, должны соответствовать формату в задании 1. Протестируйте работу описанных классов так же, как и в задании 1. 
Пример класса объекта-посредника (данный пример предлагает один из вариантов, причем не самый лучший, он легко может быть изменен и оптимизирован):
public class <Интерфейс>Synchronizer {
    private <Интерфейс>  i;
    private volatile int current = 0;
    private Object lock = new Object();
    private boolean set = false;
   
    public <Интерфейс>Synchronizer(<Интерфейс> i) {
        this.i = i;
    }
   
    public double read() throws InterruptedException {
        double val;
        synchronized(lock) {
            if (!canRead()) throw new InterruptedException();
            while (!set)
                lock.wait();
            val = i.getElement(current++);
            System.out.println("Read: " + val);
            set = false;
            lock.notifyAll();
        }
        return val;
    }  
   
    public void write(double val) throws InterruptedException {
        synchronized(lock) {
            if (!canWrite()) throw new InterruptedException();
            while (set)
                lock.wait();
            i.setElement(current, val);
            System.out.println("Write: " + val);
            set = true;
            lock.notifyAll();
        }
    }
    
    public boolean canRead() {
        return current < i.getSize();
    }
    
    public boolean canWrite() {
        return (!set && current < i.getSize()) || (set && current < i.getSize() - 1);
    }
}
<h4>Задание 3</h4>
Добавить в класс со статическими методами обработки объектов (созданный в л. р. 4) реализацию метода <Интерфейс> synchronized<Интерфейс> (<Интерфейс> i), возвращающего ссылку на оболочку указанного интерфейса, безопасную с точки зрения многопоточности. Для этого потребуется описать новый класс, реализующий ваш интерфейс <Интерфейс> и представляющий собой оболочку, синхронизирующую все методы интерфейса (состоящую из синхронизированных методов вашего интерфейса). Протестировать его работу.
Контрольные вопросы.
1.	Многопоточный подход, особенности
2.	Класс Thread для запуска потоков
3.	Интерфейс Runnable для запуска потоков
4.	Класс Thread для управления потоками
5.	Понятие группы потоков
6.	Управление группой потоков
7.	Потоки-демоны
8.	Проблемы совместного использования ресурсов
9.	Синхронизированный блок
10.	Синхронизированный метод
11.	Поля volatile
12.	Методы класса Object для синхронизации потоков
13.	Правила прерывания потоков, запрещенные методы



